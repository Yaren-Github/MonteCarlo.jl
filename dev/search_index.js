var documenterSearchIndex = {"docs":
[{"location":"flavors/mc/#Monte-Carlo-(MC)-1","page":"MC","title":"Monte Carlo (MC)","text":"","category":"section"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see 2D Ising model).","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"You can initialize a Monte Carlo simulation of a given model simply through","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"mc = MC(model)","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"Allowed keywords are:","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"beta: inverse temperature\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nglobal_moves: wether global moves should be proposed\nglobal_rate: frequency for proposing global moves\nseed: initialize MC with custom seed","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"run!(mc)","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"Note that you can just do another run!(mc, sweeps=1000) to continue the simulation.","category":"page"},{"location":"flavors/mc/#Examples-1","page":"MC","title":"Examples","text":"","category":"section"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"flavors/mc/#Exports-1","page":"MC","title":"Exports","text":"","category":"section"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"MC.jl\"]","category":"page"},{"location":"flavors/mc/#MonteCarlo.replay!","page":"MC","title":"MonteCarlo.replay!","text":"replay(mc::MC[, configurations::Iterable = mc.configs; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"flavors/mc/#MonteCarlo.run!-Tuple{MC}","page":"MC","title":"MonteCarlo.run!","text":"run!(mc::MC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns true if the run finished and false if it cancelled early to generate a resumable save-file.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"flavors/mc/#MonteCarlo.MC","page":"MC","title":"MonteCarlo.MC","text":"Monte Carlo simulation\n\n\n\n\n\n","category":"type"},{"location":"flavors/mc/#MonteCarlo.MC-Union{Tuple{M}, Tuple{M}} where M<:Model","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M; kwargs...) where M<:Model\n\nCreate a Monte Carlo simulation for model m with keyword parameters kwargs.\n\n\n\n\n\n","category":"method"},{"location":"flavors/mc/#MonteCarlo.MC-Union{Tuple{T}, Tuple{Model,Dict{Symbol,T}}} where T","page":"MC","title":"MonteCarlo.MC","text":"MC(m::M, params::Dict)\nMC(m::M, params::NamedTuple)\n\nCreate a Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"flavors/mc/#Potential-extensions-1","page":"MC","title":"Potential extensions","text":"","category":"section"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"Pull requests are very much welcome!","category":"page"},{"location":"flavors/mc/#","page":"MC","title":"MC","text":"Heat bath (instead of Metropolis) option","category":"page"},{"location":"interfaces/MC/#Interface:-Monte-Carlo-(MC)-1","page":"MC","title":"Interface: Monte Carlo (MC)","text":"","category":"section"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor Monte Carlo (MC).","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"Example models: Ising Model","category":"page"},{"location":"interfaces/MC/#Mandatory-fields-1","page":"MC","title":"Mandatory fields","text":"","category":"section"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"l::Lattice: any Lattice","category":"page"},{"location":"interfaces/MC/#Index-of-all-methods-1","page":"MC","title":"Index of all methods","text":"","category":"section"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"Pages = [\"MC.md\"]","category":"page"},{"location":"interfaces/MC/#Mandatory-methods-1","page":"MC","title":"Mandatory methods","text":"","category":"section"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"conftype(::Type{MC}, m::Model)","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"energy(mc::MC, m::Model, conf)","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"rand(::MC, ::Model)","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"propose_local(mc::MC, m::Model, i::Int, conf, E::Float64)","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"accept_local!(mc::MC, m::Model, i::Int, conf, E::Float64, delta_i, delta_E::Float64)","category":"page"},{"location":"interfaces/MC/#Optional-methods-1","page":"MC","title":"Optional methods","text":"","category":"section"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"global_move(mc::MC, m::Model, conf, E::Float64)","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"prepare_observables(mc::MC, m::Model)","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64)","category":"page"},{"location":"interfaces/MC/#","page":"MC","title":"MC","text":"finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"models/hubbardattractive/#Attractive-Hubbard-Model-1","page":"Attractive Hubbard model","title":"Attractive Hubbard Model","text":"","category":"section"},{"location":"models/hubbardattractive/#Hamiltonian-1","page":"Attractive Hubbard model","title":"Hamiltonian","text":"","category":"section"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The Hamiltonian of the attractive (negative U) Hubbard model reads","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} \\mathcal{H} = -t \\sum{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger{i\\sigma} c{j\\sigma} + \\text{h.c.} \\right) - |U| \\sumj \\left( n{j\\uparrow} - \\frac{1}{2} \\right) \\left( n{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sumj n{j}, \\end{align}","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"where sigma denotes spin, t is the hopping amplitude, U the on-site repulsive interaction strength, mu the chemical potential and langle i j rangle indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that mu = 0 corresponds to half-filling.","category":"page"},{"location":"models/hubbardattractive/#Constructor-1","page":"Attractive Hubbard model","title":"Constructor","text":"","category":"section"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"You can create an attractive Hubbard model instance as follows,","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"model = HubbardModelAttractive(dims=1, L=8)","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"dims::Int: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL::Int: linear system size\nt::Float64 = 1.0: hopping energy\nU::Float64 = 1.0: onsite interaction strength, \"Hubbard U\"\nmu::Float64 = 0.0: chemical potential","category":"page"},{"location":"models/hubbardattractive/#Supported-Monte-Carlo-flavors-1","page":"Attractive Hubbard model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Determinant Quantum Monte Carlo (DQMC), see details below","category":"page"},{"location":"models/hubbardattractive/#DQMC-formulation-1","page":"Attractive Hubbard model","title":"DQMC formulation","text":"","category":"section"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel,","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} e^{|U|\\Delta \\tau \\left( n{i\\uparrow} - \\frac{1}{2} \\right) \\left(n{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum{s=\\pm 1} \\prod{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"The interaction matrix of the model then reads","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"\\begin{align} V{ij}(l) &= \\delta{ij} Vi(l), \\\\\nVi(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"For completeness, the hopping matrix is \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\\n-\\mu & \\text{if i == j,} \\\\\n0 & \\text{otherwise.} \\end{cases} \\end{align}","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"As neither T nor V depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor (flv=1) and benefit from operating with smaller matrices.","category":"page"},{"location":"models/hubbardattractive/#Potential-extensions-1","page":"Attractive Hubbard model","title":"Potential extensions","text":"","category":"section"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Pull requests are very much welcome!","category":"page"},{"location":"models/hubbardattractive/#","page":"Attractive Hubbard model","title":"Attractive Hubbard model","text":"Arbitrary lattices (so far only cubic lattices supported)","category":"page"},{"location":"manual/showcase/#Showcase-1","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"manual/showcase/#D-Ising-model-1","page":"Showcase","title":"2D Ising model","text":"","category":"section"},{"location":"manual/showcase/#","page":"Showcase","title":"Showcase","text":"Results: (Image: )","category":"page"},{"location":"manual/showcase/#","page":"Showcase","title":"Showcase","text":"Code:","category":"page"},{"location":"manual/showcase/#","page":"Showcase","title":"Showcase","text":"using MonteCarlo, Distributions, PyPlot, DataFrames, JLD\n\nTdist = Normal(MonteCarlo.IsingTc, .64)\nn_Ts = 2^8\nTs = sort!(rand(Tdist, n_Ts))\nTs = Ts[Ts.>=1.2]\nTs = Ts[Ts.<=3.8]\ntherm = 10^4\nsweeps = 10^3\n\ndf = DataFrame(L=Int[], T=Float64[], M=Float64[], χ=Float64[], E=Float64[], C_V=Float64[])\n\nfor L in 2 .^ [3, 4, 5, 6]\n\tprintln(\"L = \", L)\n\tfor (i, T) in enumerate(Ts)\n\t\tprintln(\"\\t T = \", T)\n\t\tbeta = 1/T\n\t\tmodel = IsingModel(dims=2, L=L)\n\t\tmc = MC(model, beta=beta)\n\t\trun!(mc, sweeps=sweeps, thermalization=therm, verbose=false)\n\t\tpush!(df, [L, T, mean(mc.obs[\"m\"]), mean(mc.obs[\"χ\"]), mean(mc.obs[\"e\"]), mean(mc.obs[\"C\"])])\n\tend\n\tflush(stdout)\nend\n\nsort!(df, [:L, :T])\n@save \"ising2d.jld\" df\n\n# plot results together\ngrps = groupby(df, :L)\nfig, ax = subplots(2,2, figsize=(12,8))\nfor g in grps\n\tL = g[:L][1]\n\tax[1].plot(g[:T], g[:E], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[2].plot(g[:T], g[:C_V], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[3].plot(g[:T], g[:M], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\n\tax[4].plot(g[:T], g[:χ], \"o\", markeredgecolor=\"black\", label=\"L=$L\")\nend\nax[1].legend(loc=\"best\")\nax[1].set_ylabel(\"Energy\")\nax[1].set_xlabel(\"Temperature\")\n\nax[2].set_ylabel(\"Specific heat\")\nax[2].set_xlabel(\"Temperature\")\nax[2].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[2].legend(loc=\"best\")\n\nax[3].set_ylabel(\"Magnetization\")\nax[3].set_xlabel(\"Temperature\")\nx = range(1.2, stop=MonteCarlo.IsingTc, length=100)\ny = (1 .- sinh.(2.0 ./ (x)).^(-4)).^(1/8)\nax[3].plot(x,y, \"k--\", label=\"exact\")\nax[3].plot(range(MonteCarlo.IsingTc, stop=3.8, length=100), zeros(100), \"k--\")\nax[3].legend(loc=\"best\")\n\nax[4].set_ylabel(\"Susceptibility χ\")\nax[4].set_xlabel(\"Temperature\")\nax[4].axvline(x=MonteCarlo.IsingTc, color=\"black\", linestyle=\"dashed\", label=\"\\$ T_c \\$\")\nax[4].legend(loc=\"best\")\ntight_layout()\nsavefig(\"ising2d.pdf\")","category":"page"},{"location":"customize/#Customize-1","page":"Customize","title":"Customize","text":"","category":"section"},{"location":"customize/#Custom-models-1","page":"Customize","title":"Custom models","text":"","category":"section"},{"location":"customize/#","page":"Customize","title":"Customize","text":"Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: Interface: Monte Carlo (MC).","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.","category":"page"},{"location":"customize/#General-remarks-for-lattice-models-1","page":"Customize","title":"General remarks for lattice models","text":"","category":"section"},{"location":"customize/#Semantics-1","page":"Customize","title":"Semantics","text":"","category":"section"},{"location":"customize/#","page":"Customize","title":"Customize","text":"For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model).","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"note: Note\nWe will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.","category":"page"},{"location":"customize/#Lattice-requirements-1","page":"Customize","title":"Lattice requirements","text":"","category":"section"},{"location":"customize/#","page":"Customize","title":"Customize","text":"The Hamiltonian of your model might impose some requirements on the AbstractLattice object that you use as it must provide you with enough lattice information.","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"It might be educating to look at the structure of the simple SquareLattice struct.","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"mutable struct SquareLattice <: AbstractCubicLattice\n   L::Int\n   sites::Int\n   neighs::Matrix{Int} # row = up, right, down, left; col = siteidx\n   neighs_cartesian::Array{Int, 3} # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx\n   sql::Matrix{Int}\n   SquareLattice() = new()\nend","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"It only provides access to next nearest neighbors through the arrays neighs and neighs_cartesian. If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the SquareLattice doesn't suffice. You could either extend this lattice or implement a NNSquareLattice for example.","category":"page"},{"location":"customize/#Custom-lattices-1","page":"Customize","title":"Custom lattices","text":"","category":"section"},{"location":"customize/#","page":"Customize","title":"Customize","text":"As described in Custom models a lattice is considered to be part of a model. Hence, most of the requirements for fields of a AbstractLattice subtype come from potential models (see Lattice requirements). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.","category":"page"},{"location":"customize/#Mandatory-fields-1","page":"Customize","title":"Mandatory fields","text":"","category":"section"},{"location":"customize/#","page":"Customize","title":"Customize","text":"Any concrete lattice type, let's call it MyLattice in the following, must be a subtype of the abstract type MonteCarlo.AbstractLattice. To work with a Monte Carlo flavor, it must internally have at least have the following field,","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"sites: number of lattice sites.","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"neighs: next nearest neighbors,","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"as most Hamiltonian will need next nearest neighbor information.","category":"page"},{"location":"customize/#","page":"Customize","title":"Customize","text":"The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in energy or propose_local which both belong to a Model.","category":"page"},{"location":"customize/#Custom-Monte-Carlo-flavors-1","page":"Customize","title":"Custom Monte Carlo flavors","text":"","category":"section"},{"location":"customize/#","page":"Customize","title":"Customize","text":"Coming soon...","category":"page"},{"location":"flavors/dqmc/#Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the Attractive Hubbard Model.","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"You can initialize a determinant quantum Monte Carlo simulation of a given model simply through","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"dqmc = DQMC(model, beta=5.0)","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Mandatory keywords are:","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"beta: inverse temperature","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Allowed keywords are:","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"delta_tau::Float64 = 0.1: imaginary time step size\nsafe_mult::Int = 10: stabilize Green's function calculations every safe_mult step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?)\ncheckerboard::Float64 = false: use Checkerboard decomposition (faster)\nsweeps: number of measurement sweeps\nthermalization: number of thermalization (warmup) sweeps\nseed: initialize DQMC with custom seed\nall_checks::Bool = true: turn off to suppress some numerical checks","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Afterwards, you can run the simulation by","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"run!(dqmc)","category":"page"},{"location":"flavors/dqmc/#Technical-details-1","page":"DQMC","title":"Technical details","text":"","category":"section"},{"location":"flavors/dqmc/#Symmetric-Suzuki-Trotter-decomposition-1","page":"DQMC","title":"Symmetric Suzuki-Trotter decomposition","text":"","category":"section"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We use the symmetric version of the Suzuki-Trotter decomposition, i.e.","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} = \\prodj e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"where T is the hopping matrix and V(l) is the interaction matrix with l an imaginary time slice index indicating an auxiliary field dependence.","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"With the imaginary time slice matrices B_l = e^-Deltatau T2 e^-Deltatau V(l) e^-Deltatau T2 the equal-time Green's function is G = left( 1 + B_M cdots B_1 right)^-1.","category":"page"},{"location":"flavors/dqmc/#Checkerboard-decomposition-1","page":"DQMC","title":"Checkerboard decomposition","text":"","category":"section"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"We provide a general algorithm to construct the \"checkerboard\" split up of a generic AbstractLattice. The only requirement is that the AbstractLattice has the following two fields,","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"n_bonds::Int: total number of bonds (lattice graph edges)\nbonds::Matrix{Int}: bond matrix of shape (n_bonds, 3). Rows correspond to bonds and columns indicate source site, target site, and bond type in this order.","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific AbstractLattice subtype.","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"MonteCarlo.build_checkerboard(l::MonteCarlo.AbstractLattice)","category":"page"},{"location":"flavors/dqmc/#MonteCarlo.build_checkerboard-Tuple{AbstractLattice}","page":"DQMC","title":"MonteCarlo.build_checkerboard","text":"build_checkerboard(l::Lattice) -> checkerboard, groups, n_groups\n\nGeneric checkerboard construction.\n\nThe methods returns     * checkerboard::Matrix{Int}: size (3, n_bonds) where                 rows = source site, target site, bondid and cols                     correspond to bonds. Sorted (along columns) in such a way                     that checkerboard[3, groups[i]] are all the bond indices                     corresponding to the i-th group.     * groups::Vector{UnitRange}: ranges indicating which columns of checkerboard                     belong to which checkerboard group.     * n_groups::Int: number of checkerboard groups.\n\n\n\n\n\n","category":"method"},{"location":"flavors/dqmc/#Effective-slice-matrices-and-Green's-function-1","page":"DQMC","title":"Effective slice matrices and Green's function","text":"","category":"section"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups a and b)","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"\\begin{align} e^{-\\Delta\\tau \\suml T+V(l)} &= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\\\\n&\\times \\left( \\prodj e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"For performance resons we internally work with effective imaginary time slice matrices","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"B_l^texteff = e^-Deltatau T_b2 e^-Deltatau T_a e^-Deltatau T_b2 e^-Deltatau V","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"instead of the original B_ls above.","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"warning: Warning\nNote that one consequence is that the field dqmc.s.greens isn't the actual Green's function but an effective one defined by \\begin{align} G &= \\left( 1 + BM \\cdots B1 \\right)^{-1} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} \\left( 1 + B^{\\text{eff}}M \\cdots B^{\\text{eff}}1 \\right)^{-1} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\\\\n&= e^{\\Delta\\tau Ta/2} e^{\\Delta\\tau Tb/2} G^{\\text{eff}} e^{-\\Delta\\tau Tb/2} e^{-\\Delta\\tau Ta/2} \\end{align}To obtain the actual equal-times Green's function, for example for measuring, use greens(dqmc::DQMC). Note that although Goverset=G^texteff} one can readily show that det G = det G^texteff holds and the Metropolis acceptance is not affected by switching to the effective matrices.","category":"page"},{"location":"flavors/dqmc/#Exports-1","page":"DQMC","title":"Exports","text":"","category":"section"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"DQMC.jl\"]","category":"page"},{"location":"flavors/dqmc/#MonteCarlo.greens-Tuple{DQMC,Integer}","page":"DQMC","title":"MonteCarlo.greens","text":"greens(mc::DQMC, l::Integer)\n\nCalculates the equal-time greens function at a given slice index l, i.e.  G_{ij}(l, l) = G_{ij}(l⋅Δτ, l⋅Δτ) = ⟨cᵢ(l⋅Δτ)cⱼ(l⋅Δτ)^†⟩.\n\nNote: This internally overwrites the stack variables Ul, Dl, Tl, Ur,  Dr, Tr, curr_U, tmp1 and tmp2. All of those can be used as temporary or output variables here, however keep in mind that other results may be  invalidated. (I.e. G = greens!(mc) would get overwritten.)\n\n\n\n\n\n","category":"method"},{"location":"flavors/dqmc/#MonteCarlo.greens-Tuple{DQMC}","page":"DQMC","title":"MonteCarlo.greens","text":"greens(mc::DQMC)\n\nObtain the current equal-time Green's function, i.e. the fermionic expectation value of Gᵢⱼ = ⟨cᵢcⱼ^†⟩. The indices relate to sites and flavors, but the exact meanign depends on the model. For the attractive Hubbard model G[i, j] = ⟨c_{i, ↑} c_{j, ↑}^†⟩ = ⟨c_{i, ↓} c_{j, ↓}^†⟩ due to symmetry.\n\nInternally, mc.s.greens is an effective Green's function. This method transforms it to the actual Green's function by multiplying hopping matrix exponentials from left and right.\n\n\n\n\n\n","category":"method"},{"location":"flavors/dqmc/#MonteCarlo.replay!","page":"DQMC","title":"MonteCarlo.replay!","text":"replay(mc::DQMC[; configurations::Iterable = mc.configs; kwargs...])\n\nReplays previously generated configurations and measures observables along the way.\n\nKeyword Arguments (both):\n\nverbose = true: If true, print progress messaged to stdout.\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, replay! will generate a\n\nresumable save file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nfilename: Name of the save file. The default is based on safe_before.\nstart=1: The first sweep in the simulation. This will be changed when using\n\nresume!(save_file).\n\nignore: A collection of measurement keys to ignore. Defaults to the key of\n\nthe configuration measurement.\n\nmeasure_rate = 1: Rate at which measurements are taken. Note that this is \n\nbased on the recorded configurations, not actual sweeps.\n\n\n\n\n\n","category":"function"},{"location":"flavors/dqmc/#MonteCarlo.run!-Tuple{DQMC}","page":"DQMC","title":"MonteCarlo.run!","text":"run!(mc::DQMC[; kwargs...])\n\nRuns the given Monte Carlo simulation mc. Returns true if the run finished and false if it cancelled early to generate a resumable save-file.\n\nKeyword Arguments:\n\nverbose = true: If true, print progress messaged to stdout.\nthermalization: Number of thermalization sweeps. Uses the value passed to\n\nDQMC by default.\n\nsweeps: Number of measurement sweeps. Uses the value passed to DQMC by\n\ndefault.\n\nsafe_every::TimePeriod: Set the interval for regularly scheduled saves.\nsafe_before::Date: If this date is passed, run! will generate a resumable\n\nsave file and exit\n\ngrace_period = Minute(5): Buffer between the current time and safe_before.\n\nThe time required to generate a save file should be included here.\n\nresumable_filename: Name of the resumable save file. The default is based on\n\nsafe_before.\n\noverwrite = false: If set to true a file with the same name as\n\nresumable_filename will be overwritten. (This will create a temporary backup)\n\nSee also: resume!\n\n\n\n\n\n","category":"method"},{"location":"flavors/dqmc/#MonteCarlo.DQMC","page":"DQMC","title":"MonteCarlo.DQMC","text":"Determinant quantum Monte Carlo (DQMC) simulation\n\n\n\n\n\n","category":"type"},{"location":"flavors/dqmc/#MonteCarlo.DQMC-Union{Tuple{M}, Tuple{M}} where M<:Model","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M; kwargs...) where M<:Model\n\nCreate a determinant quantum Monte Carlo simulation for model m with keyword parameters kwargs.\n\nKeyword Arguments:\n\nseed: The random seed used by the simulation.\ncheckerboard=false: If true, the simulation uses a generic checkerboard\n\ndecomposition.\n\nthermalization_measurements::Dict{Symbol, AbstractMeasurement}: A collection\n\nof measurements run during the thermalization stage. By default, none are used.\n\nmeasurements::Dict{Symbol, AbstractMeasurement}: A collection of measurements\n\nrun during the measurement stage. Calls default_measurements if not specified.\n\nrecorder = ConfigRecorder: Type of recorder used for saving configurations\n\ngenerated during the simulation. Used (by default) when replay!ing simulations.  (Discarder or ConfigRecorder)\n\nrecording_rate = measure_rate: Rate at which configurations are recorded.\nthermalization = 100: Number of thermalization sweeps\nsweeps: Number of measurement sweeps\nall_checks = true: Check for Propagation instabilities and sign problems.\nsafe_mult = 10: Number of \"safe\" matrix multiplications. Every safe_mult\n\nmultiplications, a UDT decomposition is used to stabilize the product.\n\ndelta_tau = 0.1: Time discretization of the path integral\nbeta::Float64: Inverse temperature used in the simulation\nslices::Int = beta / delta_tau: Number of imaginary time slice in the\n\nsimulation\n\nmeasure_rate = 10: Number of sweeps discarded between every measurement.\nglobal_moves = false:: Currently not used\nglobal_rate = 5: Currently not used\nlast_sweep = 0: Sets the index of the last finished sweep. The simulation\n\nwill start with sweep last_sweep + 1.\n\n\n\n\n\n","category":"method"},{"location":"flavors/dqmc/#MonteCarlo.DQMC-Union{Tuple{T}, Tuple{Model,Dict{Symbol,T}}} where T","page":"DQMC","title":"MonteCarlo.DQMC","text":"DQMC(m::M, params::Dict)\nDQMC(m::M, params::NamedTuple)\n\nCreate a determinant quantum Monte Carlo simulation for model m with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"flavors/dqmc/#Potential-extensions-1","page":"DQMC","title":"Potential extensions","text":"","category":"section"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"Pull requests are very much welcome!","category":"page"},{"location":"flavors/dqmc/#","page":"DQMC","title":"DQMC","text":"todo","category":"page"},{"location":"lattices/#Lattices-1","page":"Lattices","title":"Lattices","text":"","category":"section"},{"location":"lattices/#","page":"Lattices","title":"Lattices","text":"The package ships with a couple of standard lattices","category":"page"},{"location":"lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.Chain 1-dimensional chain\nMonteCarlo.SquareLattice 2-dimensional square lattice\nMonteCarlo.CubicLattice D-dimensional cubic lattice","category":"page"},{"location":"lattices/#","page":"Lattices","title":"Lattices","text":"It also provides routines to load the following common lattice formats","category":"page"},{"location":"lattices/#","page":"Lattices","title":"Lattices","text":"Type Description\nMonteCarlo.ALPSLattice ALPS simple lattice graph (XML file)","category":"page"},{"location":"lattices/#Didn't-find-your-desired-lattice?-1","page":"Lattices","title":"Didn't find your desired lattice?","text":"","category":"section"},{"location":"lattices/#","page":"Lattices","title":"Lattices","text":"Just implement your own lattice for later use in a model of choice. See Custom lattices.","category":"page"},{"location":"methods/general/#Methods:-General-1","page":"General","title":"Methods: General","text":"","category":"section"},{"location":"methods/general/#","page":"General","title":"General","text":"Below you find all general exports.","category":"page"},{"location":"methods/general/#Index-1","page":"General","title":"Index","text":"","category":"section"},{"location":"methods/general/#","page":"General","title":"General","text":"Pages = [\"general.md\"]","category":"page"},{"location":"methods/general/#Documentation-1","page":"General","title":"Documentation","text":"","category":"section"},{"location":"methods/general/#","page":"General","title":"General","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"abstract.jl\"]","category":"page"},{"location":"methods/general/#Base.length-Tuple{AbstractLattice}","page":"General","title":"Base.length","text":"length(l::AbstractLattice)\n\nNumber of lattice sites.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#Base.size-Tuple{AbstractLattice}","page":"General","title":"Base.size","text":"size(l::AbstractLattice)\n\nReturns the linear system size of a lattice.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#MonteCarlo.lattice-Union{Tuple{T}, Tuple{T}} where T<:Model","page":"General","title":"MonteCarlo.lattice","text":"lattice(model)\n\nReturns the lattice of a given model.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#MonteCarlo.neighbors-Tuple{AbstractLattice,Integer}","page":"General","title":"MonteCarlo.neighbors","text":"neighbors(l::AbstractLattice, site_index::Integer)\n\nReturns a list of site indices neighboring the specified site_index.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#MonteCarlo.neighbors-Tuple{AbstractLattice}","page":"General","title":"MonteCarlo.neighbors","text":"neighbors(l::AbstractLattice[, directed=Val(false)])\n\nReturns an iterator over bonds, given as tuples (source index, target index). If directed = Val(true) bonds are assumed to be directed, i.e. both (1, 2) and (2, 1) are included. If directed = Val(false) bonds are assumed to be undirected, i.e. (1, 2) and (2, 1) are assumed to be equivalent and only one of them will be included.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#MonteCarlo.parameters-Tuple{Model}","page":"General","title":"MonteCarlo.parameters","text":"parameters(model)\n\nCollects relevant parametrs of a model into a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#MonteCarlo.reset!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.reset!","text":"reset!(mc::MonteCarloFlavor)\n\nResets the Monte Carlo simulation mc. Previously set parameters will be retained.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#MonteCarlo.run!-Tuple{MonteCarloFlavor}","page":"General","title":"MonteCarlo.run!","text":"run!(mc)\n\nRun the Monte Carlo Simulation.\n\n\n\n\n\n","category":"method"},{"location":"methods/general/#MonteCarlo.AbstractLattice","page":"General","title":"MonteCarlo.AbstractLattice","text":"Abstract definition of a lattice.\n\n\n\n\n\n","category":"type"},{"location":"methods/general/#MonteCarlo.Model","page":"General","title":"MonteCarlo.Model","text":"Abstract model.\n\n\n\n\n\n","category":"type"},{"location":"methods/general/#MonteCarlo.MonteCarloFlavor","page":"General","title":"MonteCarlo.MonteCarloFlavor","text":"Abstract definition of a Monte Carlo flavor.\n\n\n\n\n\n","category":"type"},{"location":"interfaces/DQMC/#Interface:-Determinant-Quantum-Monte-Carlo-(DQMC)-1","page":"DQMC","title":"Interface: Determinant Quantum Monte Carlo (DQMC)","text":"","category":"section"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor Determinant Quantum Monte Carlo (DQMC).","category":"page"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Example models: Attractive Hubbard Model","category":"page"},{"location":"interfaces/DQMC/#Mandatory-fields-1","page":"DQMC","title":"Mandatory fields","text":"","category":"section"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"l::AbstractLattice: any AbstractLattice\nflv::Int: number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape (flv*N, flv*N), where N is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the Attractive Hubbard Model as an example where flv=1 although it has spinful fermions.","category":"page"},{"location":"interfaces/DQMC/#Index-of-all-methods-1","page":"DQMC","title":"Index of all methods","text":"","category":"section"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"Pages = [\"DQMC.md\"]","category":"page"},{"location":"interfaces/DQMC/#Mandatory-methods-1","page":"DQMC","title":"Mandatory methods","text":"","category":"section"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"CurrentModule = MonteCarlo","category":"page"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"conftype(::Type{DQMC}, m::Model)","category":"page"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"rand(::DQMC, ::Model)","category":"page"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"hopping_matrix(mc::DQMC, m::Model)","category":"page"},{"location":"interfaces/DQMC/#MonteCarlo.hopping_matrix-Tuple{DQMC,Model}","page":"DQMC","title":"MonteCarlo.hopping_matrix","text":"hopping_matrix(mc::DQMC, m::Model)\n\nCalculates the hopping matrix T_isigma jsigma  where i j are  site indices and sigma  sigma  are flavor indices (e.g. spin indices).  The hopping matrix should also contain potential chemical potential terms on the  diagonal.\n\nA matrix element is the hopping amplitude for a hopping process: jsigma   rightarrow isigma.\n\nRegarding the order of indices, if T[i, σ, j, σ'] is your desired 4D hopping  array, then reshape(T, (n_sites * n_flavors, :)) is the hopping matrix.\n\n\n\n\n\n","category":"method"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"interaction_matrix_exp!(mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.)","category":"page"},{"location":"interfaces/DQMC/#MonteCarlo.interaction_matrix_exp!","page":"DQMC","title":"MonteCarlo.interaction_matrix_exp!","text":"interaction_matrix_exp!(\n    mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.\n) -> nothing\n\nCalculate the interaction matrix exponential  expV = exp(- power * delta_tau * V(slice)) and store it in result::Matrix.  Potential chemical potential terms should be part of the hopping_matrix and  not the interaction.\n\nThis is a performance critical method and one might consider efficient in-place  (in result) construction.\n\n\n\n\n\n","category":"function"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"propose_local(mc::DQMC, m::Model, i::Int, conf, E_boson::Float64)","category":"page"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"accept_local(mc::DQMC, m::Model, i::Int, slice::Int, conf, delta, detratio, delta_E_boson)","category":"page"},{"location":"interfaces/DQMC/#Optional-methods-1","page":"DQMC","title":"Optional methods","text":"","category":"section"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"greenseltype(::Type{DQMC}, m::Model)","category":"page"},{"location":"interfaces/DQMC/#MonteCarlo.greenseltype-Tuple{Type{DQMC},Model}","page":"DQMC","title":"MonteCarlo.greenseltype","text":"greenseltype(::Type{DQMC}, m::Model)\n\nReturns the type of the elements of the Green's function matrix. Defaults to      ComplexF64.\n\n\n\n\n\n","category":"method"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"energy_boson(mc::DQMC, m::Model, conf)","category":"page"},{"location":"interfaces/DQMC/#MonteCarlo.energy_boson-Tuple{DQMC,Model,Any}","page":"DQMC","title":"MonteCarlo.energy_boson","text":"energy(mc::DQMC, m::Model, conf)\n\nCalculate bosonic part (non-Green's function determinant part) of energy for  configuration conf for Model m.\n\n\n\n\n\n","category":"method"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"prepare_observables(mc::DQMC, m::Model)","category":"page"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf)","category":"page"},{"location":"interfaces/DQMC/#","page":"DQMC","title":"DQMC","text":"finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable})","category":"page"},{"location":"manual/gettingstarted/#Getting-Started-1","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"manual/gettingstarted/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"MonteCarlo.jl hasn't yet been released. To clone the package execute the following command in the Julia REPL:","category":"page"},{"location":"manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"Pkg.clone(\"https://github.com/crstnbr/MonteCarloObservable.jl\")\nPkg.clone(\"https://github.com/crstnbr/MonteCarlo.jl\")","category":"page"},{"location":"manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"To update to the latest version of the package just do Pkg.update() or specifically Pkg.update(\"MonteCarlo\").","category":"page"},{"location":"manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nThe package is still in pre-alpha phase and shouldn't yet be used for production runs.","category":"page"},{"location":"manual/gettingstarted/#Usage-1","page":"Getting started","title":"Usage","text":"","category":"section"},{"location":"manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model:","category":"page"},{"location":"manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"# load packages\nusing MonteCarlo\n\n# load your model\nm = IsingModel(dims=2, L=8);\n\n# choose a Monte Carlo flavor and run the simulation\nmc = MC(m, beta=0.35);\nrun!(mc, sweeps=1000, thermalization=1000, verbose=false);\n\n# analyze results\nobservables(mc) # what observables do exist for that simulation?\nm = mc.obs[\"m\"] # magnetization\nmean(m)\nstd(m) # one-sigma error\n\n# create standard plots\nhist(m)\nplot(m)","category":"page"},{"location":"manual/gettingstarted/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: logo)","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe documentation is out-of-date!","category":"page"},{"location":"#Included-models:-1","page":"Introduction","title":"Included models:","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Ising model\nAttractive Hubbard model","category":"page"},{"location":"#Included-Monte-Carlo-flavors-1","page":"Introduction","title":"Included Monte Carlo flavors","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Classical Monte Carlo\nDeterminant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)","category":"page"},{"location":"#Included-lattices-1","page":"Introduction","title":"Included lattices","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Cubic lattices (chain, square, cube, ...)\nAny ALPS lattice","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Have a look at the Showcase section to get some inspiration.","category":"page"},{"location":"#Study-your-own-model-1","page":"Introduction","title":"Study your own model","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that MonteCarlo.jl allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: Interface: Monte Carlo (MC). Practically, it makes sense to start by taking a look at the implementation of one of the predefined models.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a pull request!","category":"page"},{"location":"#GitHub-1","page":"Introduction","title":"GitHub","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MonteCarlo.jl is open-source. The source code can be found on github. Criticism and contributions are very much welcome - just open an issue. For more details see the Contribution Guide.","category":"page"},{"location":"models/ising/#Ising-Model-1","page":"Ising model","title":"Ising Model","text":"","category":"section"},{"location":"models/ising/#Hamiltonian-1","page":"Ising model","title":"Hamiltonian","text":"","category":"section"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"The famous Hamiltonian of the Ising model is given by","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"\\begin{align} \\mathcal{H} = -\\sum{\\langle i,j \\rangle} \\sigmai \\sigma_j , \\end{align}","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"where langle i j rangle indicates that the sum has to be taken over nearest neighbors.","category":"page"},{"location":"models/ising/#Creating-an-Ising-model-1","page":"Ising model","title":"Creating an Ising model","text":"","category":"section"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"You can create an Ising model as follows,","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"model = IsingModel(; dims::Int=2, L::Int=8)","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"The following parameters can be set via keyword arguments:","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"dims: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\nL: linear system size","category":"page"},{"location":"models/ising/#Supported-Monte-Carlo-flavors-1","page":"Ising model","title":"Supported Monte Carlo flavors","text":"","category":"section"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"Monte Carlo (MC) (Have a look at the examples section below)","category":"page"},{"location":"models/ising/#Examples-1","page":"Ising model","title":"Examples","text":"","category":"section"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"You can find example simulations of the 2D Ising model under Getting started and here: 2D Ising model.","category":"page"},{"location":"models/ising/#Exports-1","page":"Ising model","title":"Exports","text":"","category":"section"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"Modules = [MonteCarlo]\nPrivate = false\nOrder   = [:function, :type]\nPages = [\"IsingModel.jl\"]","category":"page"},{"location":"models/ising/#MonteCarlo.IsingModel-Union{Tuple{Dict{Symbol,T}}, Tuple{T}} where T","page":"Ising model","title":"MonteCarlo.IsingModel","text":"IsingModel(params::Dict)\nIsingModel(params::NamedTuple)\n\nCreate an Ising model with (keyword) parameters as specified in the dictionary/named tuple params.\n\n\n\n\n\n","category":"method"},{"location":"models/ising/#Analytic-results-1","page":"Ising model","title":"Analytic results","text":"","category":"section"},{"location":"models/ising/#Square-lattice-(2D)-1","page":"Ising model","title":"Square lattice (2D)","text":"","category":"section"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"The model can be solved exactly by transfer matrix method (Onsager solution). This gives the following results.","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"Critical temperature: T_c = frac2ln1+sqrt2","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"Magnetization (per site): m = left(1-leftsinh 2beta right^-4right)^frac 18","category":"page"},{"location":"models/ising/#Potential-extensions-1","page":"Ising model","title":"Potential extensions","text":"","category":"section"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"Pull requests are very much welcome!","category":"page"},{"location":"models/ising/#","page":"Ising model","title":"Ising model","text":"Arbitrary dimensions\nMagnetic field\nMaybe explicit J instead of implicit J=1\nNon-cubic lattices (just add lattice::AbstractLattice keyword)","category":"page"}]
}
